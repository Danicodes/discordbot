import os,sys
import argparse
import asyncio
import logging
from dotenv import dotenv_values
from signal import SIGINT, SIGTERM

import discord
from discord.ext import commands

from cogs import admin

# To register your bot application go to: discord.com/developers/applications
# Set up your bot with the necessary permissions, then generate an invite link
# The generated invite link will allow you (the user) to select which server to invite your bot to

config = dotenv_values()   

# Set up a logging handler for the bot (when run with bot.start)
logger = logging.getLogger()
logger.setLevel(logging.INFO)

dt_fmt = '%Y-%m-%d %H:%M:%S'
handler = logging.StreamHandler(sys.stdout)
formatter = logging.Formatter('%(asctime)s:%(name)s:(%(levelname)s):: %(message)s', dt_fmt)
handler.setFormatter(formatter)
logger.addHandler(handler)


class Bot(commands.Bot): 
    def __init__(self):
        intents = discord.Intents.default() # Almost like permissions, you can pass specific ones; all; default or none
        intents.message_content = True
        intents.members = True

        super().__init__(command_prefix='!', description="A chatbot for demo", intents=intents)
   
    async def on_ready(self) -> None:
        """ Callback for ready event, when bot user has logged in to a specific guild
        """
        print(f"Logged in to guild as {self.user}!")
        return

    async def on_message(self, message) -> None:
        """ Callback for a 'message' event in discord.

        Args:
            message (discord.Message): Message object generated by user sending a message in a discord server
        """
        print(f"Message in {message.guild} from {message.author}: {message.content}")
        await self.process_commands(message) # Necessary when overriding message listener
        return

    async def on_command_error(self, ctx, exception) -> None:
        """Listener for errors raised when a command is called"""
        if isinstance(exception, commands.CommandNotFound):
            await ctx.send("Command not found") 
            return
        return await super().on_command_error(ctx, exception)

def generate_invite() -> str:
    """
    Create an invite url for your bot; leads to discord portal where you (logged in with a user account) can invite the bot user to a server
    """
    invite_url = f"https://discordapp.com/oauth2/authorize?client_id={config['CLIENT_ID']}&scope=bot&permissions={config['PERMISSIONS']}"
    return invite_url

    # !MISTAKE!
    # @commands.command(name="ping") # Is run before init and so does not belong to the bot 
    # async def ping(self, ctx):
    #     await ctx.send("pong")

async def init_bot():
    bot = Bot()

    # Load our first command right away! 
    @bot.command()
    async def ping(ctx: commands.Context):
        """ A ping command to test successful start up of the bot

        Args:
            ctx (commands.Context): context in which command is invoked
        """
        await ctx.send("pong!")

    # @bot.command(name="admin") 
    # async def admin_load(ctx):
    #    """ Load the admin cog in a main function (works with synchronous main function call)
    #    """
    #     await admin.setup(bot)

    # Abstracts some errors unless you've explicitly configured logging to do otherwise
    #bot.run(config['CLIENT_SECRET'], root_logger=True)

    # Note bot.run vs bot.start
    # bot.run creates an asynchronous task that runs bot start, provides a logger for you
    # bot.start requires you provide a logging handler yourself
    #asyncio.run def -> execute the coroutine and return the result

    async with bot:
        # Must be used within an asynchronous main function (async def main)
        await admin.setup(bot)
        #await bot.run(config['CLIENT_SECRET'])
        await bot.start(config['TOKEN']) # Authenticates a valid bot user based on your application settings
    
    
def parser(argv) -> argparse.ArgumentParser :
    parser = argparse.ArgumentParser(description="""
    Run a discord bot
    """)
    parser.add_argument(
            '-i',  '--invite',
            action='store_true',
            help="Generate an invite link for your bot to be added to discord"
            )

    args = parser.parse_args(argv)
    
    return args

def main(argv) -> None:
    args = parser(argv)

    if args.invite:
        print(f"URL: {generate_invite()}")
        return

    else:
        #main()
        #asyncio.run(main()) # Used if calling an asynchronous main function
        
        # Equivalent of asyncio.run(main()) but gracefully terminates on sigint
        loop = asyncio.new_event_loop()
        bot_task = loop.create_task(init_bot())

        for signal in [SIGINT, SIGTERM]:
            loop.add_signal_handler(signal, bot_task.cancel)
        try:
            loop.run_until_complete(bot_task)
        except asyncio.exceptions.CancelledError:
            print("\nExiting bot")
        finally:
            loop.close()


if __name__ == "__main__":
    
    exit(main(sys.argv[1:]))

  
